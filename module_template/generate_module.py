#!/usr/bin/env python3
"""
Linux Kernel Module Generator Script

This script generates a complete Linux kernel module from templates.
It creates personalized versions of the Makefile and C source file
based on the provided module name.

Usage: python3 generate_module.py <module_name> [options]

Author: A.M.R.
Date: 2025-10-09
License: GPL v2
"""

import os
import sys
import argparse
import re
from datetime import datetime
from pathlib import Path


class KernelModuleGenerator:
    """Class to generate kernel modules from templates"""
    
    def __init__(self, base_path=None):
        """Initialize the generator with base path"""
        self.base_path = base_path or Path(__file__).parent
        self.template_makefile = self.base_path / "Makefile"
        self.template_c_file = self.base_path / "template.c"
        
    def validate_module_name(self, module_name):
        """Validate that the module name follows kernel conventions"""
        # Check if name is valid (alphanumeric + underscore, no spaces)
        if not re.match(r'^[a-zA-Z][a-zA-Z0-9_]*$', module_name):
            raise ValueError(
                f"Invalid module name '{module_name}'. "
                "Module names must start with a letter and contain only "
                "letters, numbers, and underscores."
            )
        
        # Check length (reasonable limit)
        if len(module_name) > 50:
            raise ValueError(f"Module name '{module_name}' is too long (max 50 chars)")
        
        # Check for reserved names
        reserved_names = ['init', 'exit', 'main', 'kernel', 'module']
        if module_name.lower() in reserved_names:
            raise ValueError(f"'{module_name}' is a reserved name")
    
    def create_output_directory(self, module_name):
        """Create output directory for the new module"""
        output_dir = self.base_path / module_name
        
        if output_dir.exists():
            response = input(f"Directory '{module_name}' already exists. Overwrite? (y/N): ")
            if response.lower() != 'y':
                print("Operation cancelled.")
                sys.exit(0)
        
        output_dir.mkdir(exist_ok=True)
        return output_dir
    
    def generate_makefile(self, module_name, output_dir, description="Generic kernel module"):
        """Generate personalized Makefile"""
        print(f"Generating Makefile for module '{module_name}'...")
        
        # Read template Makefile
        try:
            with open(self.template_makefile, 'r') as f:
                makefile_content = f.read()
        except FileNotFoundError:
            raise FileNotFoundError(f"Template Makefile not found: {self.template_makefile}")
        
        # Replace placeholders
        makefile_content = makefile_content.replace('my_kernel_module', module_name)
        makefile_content = makefile_content.replace('A.M.R.', 'Generated by script')
        
        # Write new Makefile
        output_makefile = output_dir / "Makefile"
        with open(output_makefile, 'w') as f:
            f.write(makefile_content)
        
        print(f"Makefile created: {output_makefile}")
    
    def generate_c_file(self, module_name, output_dir, author="A.M.R.", 
                       email="amoralesruiz@hotmail.com", description="Generic kernel module"):
        """Generate personalized C source file"""
        print(f"Generating C source file for module '{module_name}'...")
        
        # Read template C file
        try:
            with open(self.template_c_file, 'r') as f:
                c_content = f.read()
        except FileNotFoundError:
            raise FileNotFoundError(f"Template C file not found: {self.template_c_file}")
        
        # Prepare replacements
        replacements = {
            '{{MODULE_NAME}}': module_name,
            '{{MODULE_NAME_UPPER}}': module_name.upper(),
            '{{MODULE_DESCRIPTION}}': description,
            'Your Name': author,
            'your.email@example.com': email,
            'amoralesruiz@hotmail.com': email,  # Ensure email replacement works
            '$(shell date)': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        }
        
        # Apply replacements
        for placeholder, replacement in replacements.items():
            c_content = c_content.replace(placeholder, replacement)
        
        # Write new C file
        output_c_file = output_dir / f"{module_name}.c"
        with open(output_c_file, 'w') as f:
            f.write(c_content)
        
        print(f"C source file created: {output_c_file}")
    
    def generate_readme(self, module_name, output_dir, description, author):
        """Generate README file for the module"""
        readme_content = f"""# {module_name.title()} Kernel Module

**Author:** {author}  
**Date:** {datetime.now().strftime('%Y-%m-%d')}  
**Description:** {description}

## Overview

This is a Linux kernel module generated from a template. It provides basic
kernel module functionality including module, proc filesystem integration,
parameters definition and proper cleanup.

## Building

To compile the module:
```bash
make
```

To clean build artifacts:
```bash
make clean
```

## Usage

### Loading the module
```bash
sudo insmod {module_name}.ko
```

### Loading with parameters
```bash
sudo insmod {module_name}.ko debug=1
```

### Checking if module is loaded
```bash
lsmod | grep {module_name}
```

### Viewing module information
```bash
modinfo {module_name}.ko
```

### Unloading the module
```bash
sudo rmmod {module_name}
```

## Module Parameters

- `debug`: Enable debug output (0=off, 1=on, default: 0)

## Proc Interface

The module creates a proc entry at `/proc/{module_name}` that can be used to:
- Read module information and status
- Write data to the module (for testing)

Example:
```bash
# Read module info
cat /proc/{module_name}

# Write to module
echo "test data" > /proc/{module_name}
```

## Development

### Quick development cycle
```bash
make reload    # Clean, build, unload old, load new
```

### Debug build
```bash
make debug     # Build with debug information
```

### Verbose build
```bash
make verbose   # Show detailed build output
```

## Kernel Messages

View kernel messages related to this module:
```bash
dmesg | grep {module_name}
```

Or use the Makefile target:
```bash
make dmesg
```

## License

This module is licensed under GPL v2.

## Notes

- Always test kernel modules in a safe environment
- Unload the module before system shutdown
- Check kernel logs for any error messages
- Modify the source code to implement your specific functionality
"""
        
        readme_file = output_dir / "README.md"
        with open(readme_file, 'w') as f:
            f.write(readme_content)
        
        print(f"README file created: {readme_file}")
    
    def generate_module(self, module_name, author="A.M.R.", 
                       email="amoralesruiz@hotmail.com", 
                       description="Generic kernel module"):
        """Generate complete kernel module to be completed"""
        try:
            # Validate module name
            self.validate_module_name(module_name)
            
            # Create output directory
            output_dir = self.create_output_directory(module_name)
            
            print(f"Generating kernel module '{module_name}'...")
            print(f"Output directory: {output_dir}")
            print("-" * 50)
            
            # Generate files
            self.generate_makefile(module_name, output_dir, description)
            self.generate_c_file(module_name, output_dir, author, email, description)
            self.generate_readme(module_name, output_dir, description, author)
            
            print("-" * 50)
            print(f"Module '{module_name}' generated successfully!")
            print(f"Location: {output_dir}")
            print("\nNext steps:")
            print(f"  cd {module_name}")
            print("  make")
            print(f"  sudo insmod {module_name}.ko")
            print(f"  dmesg | tail")
            print(f"  sudo rmmod {module_name}")
            
        except Exception as e:
            print(f"Error generating module: {e}")
            sys.exit(1)


def main():
    """Main function"""
    parser = argparse.ArgumentParser(
        description="Generate Linux kernel module from templates",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python3 generate_module.py my_driver
  python3 generate_module.py serial_port --author "John Doe" --email "john@example.com"
  python3 generate_module.py network_filter --description "Network packet filter module"
        """
    )
    
    parser.add_argument("module_name", 
                       help="Name of the kernel module to generate")
    
    parser.add_argument("--author", "-a", 
                       default="A.M.R.",
                       help="Author name (default: 'A.M.R.')")
    
    parser.add_argument("--email", "-e", 
                       default="amoralesruiz@hotmail.com",
                       help="Author email (default: 'amoralesruiz@hotmail.com')")
    
    parser.add_argument("--description", "-d", 
                       default="Generic kernel module",
                       help="Module description (default: 'Generic kernel module')")
    
    parser.add_argument("--base-path", "-p", 
                       help="Base path for templates (default: script directory)")
    
    parser.add_argument("--version", "-v", 
                       action="version", 
                       version="Kernel Module Generator 1.0")
    
    args = parser.parse_args()
    
    # Create generator instance
    generator = KernelModuleGenerator(args.base_path)
    
    # Generate module
    generator.generate_module(
        module_name=args.module_name,
        author=args.author,
        email=args.email,
        description=args.description
    )


if __name__ == "__main__":
    main()